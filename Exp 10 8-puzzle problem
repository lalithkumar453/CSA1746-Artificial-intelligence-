from collections import deque
# Function to display the puzzle in 3x3 format
def print_puzzle(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])
    print()
# Moves: Up, Down, Left, Right
moves = {
    'U': -3,
    'D': 3,
    'L': -1,
    'R': 1
}
# Function to get possible next states
def get_neighbors(state):
    neighbors = []
    zero_pos = state.index(0)  # Find empty space (0)
    for move, pos_change in moves.items():
        new_pos = zero_pos + pos_change
        # Check if move is valid
        if move == 'L' and zero_pos % 3 == 0:  # Can't move left from col 0
            continue
        if move == 'R' and zero_pos % 3 == 2:  # Can't move right from col 2
            continue
        if new_pos < 0 or new_pos >= 9:  # Out of bounds
            continue
        # Swap zero with target position
        new_state = list(state)
        new_state[zero_pos], new_state[new_pos] = new_state[new_pos], new_state[zero_pos]
        neighbors.append(tuple(new_state))

    return neighbors

# BFS Algorithm
def bfs(start, goal):
    queue = deque([(start, [])])  # (state, path)
    visited = set()
    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path
        visited.add(state)
        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
    return None
if __name__ == "__main__":
    start_state = (1, 2, 3,
                   4, 0, 6,
                   7, 5, 8)
    goal_state = (1, 2, 3,
                  4, 5, 6,
                  7, 8, 0)
    print("Start State:")
    print_puzzle(start_state)
    print("Goal State:")
    print_puzzle(goal_state)
    solution = bfs(start_state, goal_state)
    if solution:
        print("Steps to solve (sequence of states):")
        for step in solution:
            print_puzzle(step)
    else:
        print("No solution found.")
